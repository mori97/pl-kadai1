# 「プログラミング言語」課題１レポート

* 氏名: DU YICHENG
* 学部・学科・コース: 工学部情報学科計算機科学コース
* 学生番号: 1029-28-2571

## 課題1-1-1
計算木のためのインターフェス Tree を使い、
加算の枝 BranchS クラスと乗算の枝 BranchM クラスと値を格納する葉 Leaf クラスを
作成した。Leaf クラスのコンストラクタは、葉の価値を受け取り、それをインスタンス
変数に格納する。BranchS クラスと BranchM クラスのコンストラクタは、左の部分木と
右の部分木を引数として受け取り、インスタンス変数 left と right に格納する。
木の価値を返すメソッド value() も定義した。Leaf クラスの value() メソッドは
自身の価値を格納している value 変数の値をそのまま返す。BranchS クラス及び
BranchM クラスの value() メソッドは再帰呼出しで左の部分木と右の部分木に対して
value() を呼び出し、加算または乗算を行う。

## 課題1-1-2
枝の価値が(左の部分木の価値)^(右の部分木の価値)となるタイプ X の枝
(BranchX クラス)を追加した。
コンストラクタは課題 1-1-1 と同じように定義した。value() も BranchS と BranchM
と同じように定義したが、'+' と '*' 演算子の代わりに累乗のメソッド Math.pow を
使用した。

同時に、TestCase.java に BranchX のテストを追加した。

## 課題1-1-3
(タイプ X も考慮した)  
計算木の価値を表す計算式の文字列を返すメソッド toString() を作成した。Leaf
クラスの toString() は価値 value を文字列に変換して返す。各枝のクラスの
toString() は左の部分木と右の部分木の toString() メソッドを呼び出してその計算式
を取得し、ブランチの種類に応じて適切な演算子でくっつけ、括弧で囲んでから返す
メソッドで、再帰メソッドになっている。

## 課題1-1-4
(タイプ X も考慮した)  
計算木の価値を表す文字列を適宜に括弧を省いた形で取得するメソッド
toStringFewerParens() を作成した。枝のタイプ及び部分木のタイプに応じて細かく
場合分けをしている。

* Leaf の場合  
価値を表す変数を文字列に変換して返す。
* BranchS の場合  
'+' 演算子の優先順位が一番低いので、部分木が BranchM または BranchX の場合には
括弧を囲む必要がないが、左結合の演算子のため、右の部分を括弧で囲む必要がある。
* BranchM の場合  
'*' 演算子の優先順位は '^' 演算子より低いが、'+' 演算子より高いので、部分木が
BranchS の場合にはそれを括弧で囲まなければならない。左結合の演算子であるため、
右の部分木が BranchM の場合に右の部分を括弧で囲む必要がある。それ以外の場合は
括弧で囲まない。
* BranchX の場合  
'^' 演算子の優先順位が最も高いので、部分木が Leaf の場合以外は括弧で囲む必要
があるが、右結合演算子であるため、右の部分木が BranchX の場合は括弧で囲ま
なくても良い。

以上の場合分けに従って toStringFewerParens() を実装した。コードの可読性を
上げるために、String.format を活用するなどの工夫もした。

## 課題1-1-5
(タイプ X も考慮した)  
計算木中の葉を数えるメソッド countLeaf() は、葉の場合に 1 を、ブランチの場合に
左の部分木.countLeaf() + 右の部分木.countLeaf() を返す再帰呼出しのメソッドに
なっている。  
計算木の高さを数えるメソッド height() は、葉の場合に 0 を、ブランチの場合に
左の部分木.height() と右の部分木.height() の大きい方足す 1 を返す再帰呼出しの
メソッドになっている。

## 課題1-1-6
(タイプ X も考慮した)  
木の簡約操作を行うメソッド reduce() を実装した。reduce() メソッドも再帰呼び出しの
メソッドになっている。Leaf は簡約できないため、Leaf の reduce() メソッドは
自身を返す(Leaf の価値が変更されることはないので元の木が破壊される心配はない)。
ブランチの場合、部分木として葉を二つ持つブランチは絶対に存在するので、深さ優先
探索を行えば良い。ブランチの reduce() メソッドは左の部分木が葉でない場合、左の
部分木が元の部分木に reduce() メソッドを適用した木で右の部分木が元のままの
ブランチを返し、左の部分木が葉である場合、左の
部分木がそのままで右の部分木が元の右の部分木に reduce() を適用したものを返す。
木が一つの葉しかない場合以外、新しい計算木はすべて new Branch◯ で作られるので、
同様に元の木が壊されず、永続的なデータ構造になっている。

## 課題1-1-7
(タイプ X も考慮した)  
計算木中の価値が n である葉を計算木 t で置換するメソッド subst(n, t) を実装した。
Leaf クラスの subst メソッドは、与えられた n が自身の価値に一致すれば計算木 t を
返し、一致しないなら自身を返すメソッドになっている。各ブランチの subst メソッド
は再帰呼出しになっており、左の部分木が元の左の部分木に subst メソッドを適用した
もので、右の部分木が元の右の部分木に subst メソッドを適用した新しいブランチを
返す。ブランチの subst メソッドは新しいブランチオブジェクトを作っており、Leaf
クラスの価値が変更されることはないため、永続的なデータ構造になっている。

## 課題1-2-1
計算木の価値を計算する関数 value\_of\_tree を作成した。計算木の価値は左の部分木の
和と右の部分木の価値の和または積なので、ブランチの場合は再帰呼び出しで左の部分木
の価値と右の部分木の価値の和または積を返し、葉の場合は自身の価値を返す。  
(課題 1-2-2 で新しい種類のブランチ BranchX を作成してそのテストを追加した後、
課題 1-2-1 のテストがエラーを吐くようになったので、BranchX の場合にダミーの値 0
を返すようにした。)

## 課題1-2-2
(左の部分木の価値)の(右の部分木の)乗を価値とする新しい枝 BranchX を追加し、
BranchX も考慮した計算木の価値を返す関数 value\_of\_tree2 を実装した。n の m 乗
(n, m は整数) を計算する関数 pow n m を作成し、課題 1-2-1 で作成した関数を元に、
BranchX の場合の計算を追加した。

## 課題1-2-3
(タイプ X も考慮した)  
計算木の価値を表す計算式の文字列を返す関数 string\_of\_tree を作成した。引数に対し
パターンマッチングを行い、引数が Leaf の場合は自身の価値を文字列に変換してから
返す。枝の場合は再帰呼出しで左の部分木と右の部分木の計算式を取得し、枝の種類に
応じて適切な演算子でくっつけ、括弧で囲んでから返す。

## 課題1-2-4
(タイプ X も考慮した)  
計算木の価値を表す文字列を適宜に括弧を省いた形で取得する関数
string\_of\_tree\_fewer\_parens を作成した。枝のタイプ及び部分木のタイプに応じて
細かく場合分けをしている。

* Leaf の場合  
価値を表す変数を文字列に変換して返す。
* BranchS の場合  
'+' 演算子の優先順位が一番低いので、部分木が BranchM または BranchX の場合には
括弧を囲む必要がないが、左結合の演算子のため、右の部分を括弧で囲む必要がある。
* BranchM の場合  
'*' 演算子の優先順位は '^' 演算子より低いが、'+' 演算子より高いので、部分木が
BranchS の場合にはそれを括弧で囲まなければならない。左結合の演算子であるため、
右の部分木が BranchM の場合に右の部分を括弧で囲む必要がある。それ以外の場合は
括弧で囲まない。
* BranchX の場合  
'^' 演算子の優先順位が最も高いので、部分木が Leaf の場合以外は括弧で囲む必要
があるが、右結合演算子であるため、右の部分木が BranchX の場合は括弧で囲ま
なくても良い。

以上の場合分けに従って、OCaml で再帰関数 string\_of\_tree\_fewer\_parens を
実装した。

## 課題1-2-5
(タイプ X も考慮した)  
計算木中の葉を数える関数 count\_leaf と 計算木の高さを返す関数 height を
実装した。  
count\_leaf 関数は、葉の場合に 1 を、ブランチの場合に count\_leaf (左の部分木) + 
count\_leaf (右の部分木) を返す再帰関数になっている。  
height 関数は、葉の場合に 0 、ブランチの場合に height (左の部分木) と 
height (右の部分木) の大きい方足す 1 を返す再帰関数なっている。

## 課題1-2-6
(タイプ X も考慮した)  
木の簡約操作を行う再帰関数 reduce を実装した。Leaf は簡約できないため、Leaf の
場合は受け取った Leaf と同じ価値を持つ Leaf を返す。
ブランチの場合、部分木として葉を二つ持つブランチは絶対に存在するので、深さ優先
探索を行えば良い。枝を受け取ったの reduce 関数は左の部分木が葉でない場合、左の
部分木が元の部分木に reduce 関数を適用した木で右の部分木が元のままの
ブランチを返し、左の部分木が葉である場合、左の部分木がそのままで右の部分木が
元の右の部分木に reduce 関数を適用したものを返す。

## 課題1-2-7
(タイプ X も考慮した)  
計算木 t 中の価値が n である葉を計算木 t' で置換する関数 subst(t, n, t) を
実装した。
t が Leaf の場合、subst 関数は与えられた n が t の価値に一致すれば計算木 t' を
返し、一致しないなら t を返す。t が枝の場合、subst が再帰呼び出しで subst を
呼び出し、左の部分木が元の左の部分木に subst 関数を適用したもので、右の部分木が
元の右の部分木に subst 関数を適用した新しいブランチを返す関数になっている。
